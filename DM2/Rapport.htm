<html>
<head>
    <title>IFT3911 DM2 Juliett</title>
    <style type="text/css">
        table
        {
            border: outset 2px black;
            border-collapse: collapse;
            width: 90%;
        }
        
        th
        {
            border-bottom: double 2px black;
        }
        td
        {
            border-bottom: solid 1px black;
        }
        .first_col
        {
            border-right: double 2px black;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">
        IFT 3911 - Devoir 2</h1>
    <h2>
        Information générale</h2>
    <p>
        <span style="font-weight: bold;">Nom: </span>Kanty-Louange Gakima
        <br />
        <span style="font-weight: bold;">Matricule: </span>20184109
        <br />
        <span style="font-weight: bold;">Courriel: </span>kanty.louange.gakima@umontreal.ca
        <br />
        <span style="font-weight: bold;">temps mis: </span>~ 20 heures
    </p>
    <p>
        <span style="font-weight: bold;">Nom: </span>Marianne Schmit Pemmerl
        <br />
        <span style="font-weight: bold;">Matricule: </span>20192143
        <br />
        <span style="font-weight: bold;">Courriel: </span>marianne.schmit.pemmerl@umontreal.ca
        <br />
        <span style="font-weight: bold;">temps mis: </span>~ 20 heures
    </p>
    <h2>
        Distribution des tâches</h2>
    <p>
        <span style="font-weight: bold;">Soumetteur: Marianne Schmit Pemmerl </span>
    </p>
    <table cellpadding="7px">
        <thead>
            <tr>
                <th class="first_col">
                    Nom
                </th>
                <th>
                  Tâches 
                </th>
               
            </tr>
        </thead>
        <tbody>
            <tr>
                <td class="first_col">
                    Kanty
                </td>
                <td>
                    Statechart,Modèle du design(50%), Diagramme de paquet(50%), Discussion du fardeau, graphe IA et Justification, Discussion du couplage et de la cohesion des modules, Identification des modules réutilisables, Justification de l'application des principes de conception
                </td>
            
            </tr>
            <tr>
                <td class="first_col">
                    Marianne
                </td>
                <td>
                    Réseau de pétri, Modèle du design(50%), Diagramme de paquet(50%), Discussion du fardeau, graphe IA et Justification, Discussion du couplage et de la cohesion des modules, Identification des modules réutilisables, Justification de l'application des principes de conception

                </td>
       
            </tr>
        </tbody>
    </table>
    <h2>
        Hypothèses
    </h2>
    <ul>
        <li text-align="justify"> Nous avons supposé pour le réseau de pétri du tunnel qu'il ya toujours une voiture à l'entrée de chaque tunnel en tout temps

        </li>
    </ul>

    <h2>
        Tâche 1: Réseau de pétri d'un tunnel
    </h2>
    <p><img width="1500" src="./réseau de pétri.png" ></p>

    <h3>
        <u>Graphe de couverture</u>
    </h3>
    <p><img width="1000" src="./graphe de couverture.png" ></p>

    <p><img width="1000" src="./GSPN analysis.png" ></p>

    <h4 text-align="justify">
        M(tunnel est vide) = 1 <br>
        le processeur (ressource) qui est le tunnel est soit vide ou non vide(1 voiture max) <br>
        Nous pouvons remarquer que lorsqu'une voiture entre dans le tunnel et qu'aucun autre jeton 
        ne peut entrer dans “tunnel est vide" tant que le tunnel n'est pas de nouveau vide, cela 
        garantit que seule une voiture peut se trouver dans le tunnel à la fois.<br><br>

        Le système est équitable car chaque côté du tunnel a la même opportunité de 
        faire passer une voiture à travers le tunnel, c'est à dire que lorsque par exemple 
        il y a une voiture qui entre du côté de Montréal et sort du tunnel, alors la prochaine voiture 
        à entrer dans le tunnel sera celle du côté de la rive sud. Les tours sont alternés. <br><br>

        Il n'y a pas de famine car sachant qu'il y a toujours une voiture de chaque côté, le système 
        permet aux voitures d'entrer dans le tunnel de manière équitable, aucune voiture ne sera bloquée 
        indéfiniment en attente.


    </h4>
    
    <h2>
        Tâche 2: Statechart du four à micro-onde
    </h2>
	<p> <img width="1600" src="./microwave.svg" > </p>
	<p>En générant le code sur Yakindu, on a essayé pluieurs fois pour que la gération modifie les classes déjà fournies mais ça n'a pas marché,
	du coup le code généré se trouve dans Microwave.java dans le fichier src et les autres classes dans le package com.yakindu.core</p>


    <h2>
        Tâche 3: Révision
    </h2>
   

    <h3> Modèle du design </h3>
    <p><img width="1600" src="./modele du design.svg" ></p>
    
    <p>
        <h3>Diagrammes de séquence</h3>
        <ol>
            <li> vérifier les vols/lignes/itinéraires </li>
            <p><img src="./Vérifier voyage(vols_itinéraires_trajet).svg" ></p>
            <li> Réserver un siège </li>
            <p><img src="./Reservation Siege.svg" ></p>
            <li>Payer un siège</li>
            <p><img src="./Payer un siege.svg" ></p>
        </ol>
    </p>

    <p>
        <h3>Diagramme de paquets</h3>

            <p><img width="1000" src="./systeme_reservation_voyage.svg" > </p>
            
    </p>
    <p>
        <h3>Contraintes OCL</h3>
        <ol>
            <li>Un aéroport/gare/port est identifié par trois lettres uniques à chaque aéroport:<br><br>
                context Infrastructure inv: <br>
                self.id.size() = 3 and  self -> forAll( i1, i2 | i1 <> i2 implies i1.id<> i2.id )</li><br>
            
            <li>La partie alphabétique de l'ID d'un vol est unique à chaque compagnie et la partie numérique est unique à
                chaque vol au sein de la même compagnie: <br><br>
                context Compagnie inv: <br><br>
                #Les deux premiers caractères d'un ID de vol doivent être des lettres<br>
                self.vol.id.substring(1,2).isAlpha()<br>
                and <br><br>

                #Le reste des caractères d'un ID de vol doivent être des chiffres<br>
                self.vol.id.substring(3, self.vol.id.size()).isNumeric()<br>
                and<br><br>
                #Les deux premiers caractères de l'ID de vol doivent correspondre à l'ID de la compagnie <br>
                self.vol.id.substring(1, 2) = self.id<br>
                and<br><br>
                #La partie alphabétique de l'ID d'un vol est unique à chaque compagnie<br>
                self ->forAll(c1, c2 | c1 <>c2  implies c1.vol.id.substring(1, 2) <> c2.vol.id.substring(1, 2))<br>
                and<br><br>
                #La partie numérique de l'ID d'un vol est unique à chaque vol au sein de la même compagnie<br>
                self.vol ->forAll(v1, v2 | v1 <> v2 implies v1.id.substring(3, v1.id.size()) <> v2.id.substring(3, v2.id.size()))<br><br>


                </li><br>
            <li>L'aéroport de départ et d'arrivée d'un vol doit être différent: <br><br>

                Context Vol inv :<br>
	            self.pointdeDepart <>  self.pointtDarrivee </li><br>
            <li> Tous les sièges/cabines d'une même section ont le même prix: <br><br>
                Context Section inv: <br>
	            self.espace-> forAll(e1, e2 | e1 <> e2  implies e1.prix = e2.prix)</li><br>
            <li> Un itinéraire ne peut pas durer plus de 21 jours: <br><br>
                 context Itineraire inv:<br>
                 self.duree <= 504</li><br>

            <li> Le port de départ et d'arrivée doit être le même: <br><br>
            context Itineraire inv : <br>
	        self.pointDepart = pointDarrivee </li><br>
            
            <li> Un paquebot peut être assigné à plusieurs itinéraires tant qu'ils ne se chevauchent pas : <br><br>
            Context Paquebot inv:<br>
	        self.itineraire ->forAll(i1, i2 | i1 <> i2 implies ( i1.heureDarrivee <= i2.heureDepart ) </li><br>

            <li> Toutes les cabines d'une même section ont le prix: <br><br>
            Context Section inv: <br>
		    self.cabine -> forAll(c1, c2 | c1.prix = c2.prix)  </li> <br>
            <li>Le client peut réserver un siège ou cabine disponible dans un vol (trajet) donné:<br> <br>
                Context Reservation :: reserver()<br>
                    Pre : self.espace.estDispo = true<br>
                    Post : self.espace.estDispo = false</li><br>

            <li>
                Un siège réservé devient assigné à un passager une fois payé: le siège est donc confirmé: <br><br>

                context reservation:: estPaye():Booelan<br>
                    Pre: self.espace.estDiso = false and self.espace.estConfirme = false<br>
		            Post : self.espace.estConfirme = true</li><br>
            </li>
        </ol>
	        <b> Autres contraintes:<br><br> </b>
        <ul>
            <li> Un avion/un train comporte des sièges organisés en maximum 100 rangées et 10 colonnes: <br><br>
                    Context Avion inv: <br>
                        self.nombrerangees <= 10 <br>
                        self.nombreColonnes <= 100 <br><br>

                    Context Train inv: <br>
                        self.nombrerangees <= 10 <br>
                        self.nombreColonnes <= 100 <br>
            </li>
        </ul>
    </p>

    <h3>
        Modules réutilisables
    </h3>
				
    <p>
        Les modules les plus réutilisables sont: 
        <ul>
            <li> <b>Mode de transport</b> est une classe abstraite qui pourrait être utilisée dans les systèmes qui gèrent différents moyens de transport qui existent tels que l'avion, le train, le paquebot etc. </li>
            <br>
            <li><b>Voyage </b> est une classe abstraite qui pourrait être utilisée dans les systèmes qui gèrent différents type de déplacements utilisant des moyens de transport, comme que les vols aériens, les trajet férroviaires, les itinéraires navaux etc.  </li>
            <br>
            <li> <b>Infrastructure </b> est un module réutilisable car il encapsule les détails liés aux informations générales sur les infrastructures comme aéroports, gares et port. Celle ci pourrait être réutilisée dans les systèmes où il sera nécessaire d'utiliser une infrastructure </li>
            <br>
            <li><b>Espace </b>  est un module réutilisable car il encapsule les détails liés aux espaces physique tels que les sièges dans les moyens de transport, les salles de concert ou les chambres dans un hôtel etc.  </li>
            <br>
            <li><b>Compagnie </b> est un module réutilisable car il encapsule les détails liés aux  entreprises.  </li>
            <br>
            <li><b>Client </b> est un module réutilisable car il encapsule les détails liés aux  informations personnelles des utilisateurs. </li>
            <br>
            <li><b>Paiement</b> et <b>Carte </b> sont des modules réutilisable car ils encapsulent les détails liés aux transactions financières. </li>
        </ul>
    </p>

    <h2> Tâche 4 : Qualité du design</h2>
    <p>

        <ol>
            <li>
                <b>
                    Discussion du couplage et de la cohesion des modules
                </b>
            </li>

            <p style="text-align: justify;">
                <b>La cohésion</b> fait référence au degré de relation entre les éléments d'un module. <br>
                L'adoption de l'héritage pour structurer les concepts de Moyen de Transport, Voyage et Espace renforce
                la cohésion en attribuant à chaque sous-classe des responsabilitées spécifiques et bien définies, 
                évitant ainsi une surchage d'une classe unique avec des informations diverses. Pour les autres classes
                nous remarquons aussi que toutes les méthodes et attributs sont directement liés au concept que la classe est censée représenter.
                Nous pouvons ainsi conclure d'une bonne cohésion de notre diagramme de classe. <br>
                <br>
                <b>Le couplage</b> fait référence au degré d'interdépendance entre les classes. <br>
                Classes ayant un faible couplage: Compagnie, Client, Carte, Infrastructure, Vol, Trajet, Itinéraire, Avion, Train, Paquebot, Siege, Cabine, Section.
                Les changements dans ces classes ne devraient pas affecter les autres.
                <br>
                Classes ayant un fort couplage: Les controlleurs, Paiement (accède directement à la classe "Carte"), Réservation.
                Les changements dans ces classes peuvent très probablement en affecter d'autres.
                Nous pouvons ainsi conclure d'un assez bon couplage de notre diagramme de classe en général.



            </p>
            <li>
                <b>
                    Discussion du fardeau des classesz
                </b>
            </li>
            <p>
                Les classes du domaine "bas" ont un fardeau faible, ce qui implique une bonne cohesion des classes. <br>
                Voici les classes du domaine bas : Trajet, Vol, Itinéraire, Avion, Paquebot, Train, Cabine, Siege ...<br>
                <br>
                Les classes du domaine "élevé" ont un fardeau élevé, ce qui implique une bonne réutilisation des classes. <br>
                Voici les classes du domaine élevé : Mode de transport, Voyage, Espace, Paiement, Carte, Compagnie, Client, Infrastructure ... <br>

            </p>

            <li>
                <b>
                   Graphe IA et Justification
                </b>
            </li>
            <p>
                <img width="800" src="./graphe AI.png" > <br>
                <br>
                <br>
                <p>
                    Le paquet "Transport Composition" est stable mais peu abstrait, le niveau d'abstraction pourrait être amélioré. 
                    Ce dernier est potentiellement un bon candidat pour la réutilisation. <br><br>

                    Les paquets "Voyage Composition" et "Utilisateurs" ont un niveau d'abstraction et d'instabilité qui pourrait être amélioré.<br><br>

                    Le paquet "Operations Client" est le plus à risque en terme de maintenance et de réutilisation car il a une instabilité élevée et pas d'abstraction.
                    Le niveau d'abstraction pourrait être amélioré en ajoutant des abstractions ou interfaces.

                    <br><br>

                </p>

            </p>

            <li>
                <b>
                    Justification de l'application des principes de conception
                </b>
            </li>
            <br>
            <ul>
                <li> <b>SRP: Single Responsability Principle :</b> Bien utilisé<br>
                    Les classes ont une seule responsabilité, par exemple Voyage contient les informations sur le voyage, et on a 
                    Controleur voyage qui contient les opérations sur le Voyage, même chose pour Infrastructure, Reservation, etc. <br>
                    En résumé la conception est faite en respectant ce principe de conception.
                </li>
                <br>
               <li> <b> OCP(Open/Closed Principle): </b>  Bien utilisé <br> La présence de classes abstraites comme Mode_transport, voyage,etc
                     suggère que le système est conçu pour être étendu (nouveaux modes de transport peuvent être ajoutés) sans modifier les classes existantes.
               </li> 
               <br>
                <li> <b>ISP: Interface Segregation Principle :</b>Pas bien utilisé<br>
                        Appliquer ce principe de conception, implique d'utiliser plusieurs interfaces pour différents opérations
                        que l'utilisateur peut faire, mais on a utilisé des contrôleurs pour l'interface du  client et l'administrateur <br>
                  
                </li>
                <br>

                <li>
                    <b>DIP: Dependency Inversion Principle </b> Bien utilisé<br>
                    L'utilisation du DIP implique la dépendance des abstractions et non des implémentations, 
                    ce qui a été appliqué pour les modules suivants: Voyage, Mode de transport et Espace
                </li>

            </ul>

            <br>
            <li>
                <b>
                    Justification de l'application des principes de couplage de paquets
                </b>
            </li>
            <br>

            <ul>
                <li>
                    <b>ADP: Acyclic Dependency Principle </b> Bien utilisé<br>
                    En analysant le diagramme de paquets on remarque le les dépendances sont acycliques, ce qui est un bon point pour la conception.
                </li>
                <br>
                <li>
                   <b>SDP: Stable dependencies Principle</b>  Bien utilisé<br>
                   En analysant le diagramme de paquets nous pouvons remarquer que tous les paquets dépendent uniquement de paquets plus stables que 
                   lui sauf pour les paquets "Voyage Composition" et "Utilisateurs" où le niveau de stabilité est le même.
                </li>
                <br>
                <li>
                   <b>SAP: Stable Abstraction Principle</b>  Pas bien utilisé<br>
                   En analysant le diagramme de paquets nous pouvons remarquer que les paquets les plus stables ne sont pas forcément les plus abstraits.
                </li>
            </ul>
      
        </ol>
	
    </p>

</body>
</html>
